%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital, %% This option enables the default options for the
           %% digital version of a document. Replace with `printed`
           %% to enable the default options for the printed version
           %% of a document.
  table,   %% Causes the coloring of tables. Replace with `notable`
           %% to restore plain tables.
  lof,     %% Prints the List of Figures. Replace with `nolof` to
           %% hide the List of Figures.
  lot,     %% Prints the List of Tables. Replace with `nolot` to
           %% hide the List of Tables.
  %% More options are listed in the user guide at
  %% <http://mirrors.ctan.org/macros/latex/contrib/fithesis/guide/mu/fi.pdf>.
]{fithesis3}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=slovak, english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  german, russian, czech %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = mgr,
    author        =  Jerguš Fašánek,
    gender        = m,
    advisor       = {Ing. RNDr. Barbora Bühnová, Ph.D.},
    title         = {Cloudový slovníkový prekladač pre vývojárov},
    TeXtitle      = {Cloudový slovníkový prekladač pre vývojárov},
    keywords      = {slovník, cloud},
    TeXkeywords   = {slovník, cloud},
    bib           = example.bib,
}
\thesislong{abstract}{
   Cieľom diplomovej prácej je navrhnúť a vytvoriť backend pre synchronizáciu slovníkov desktopovej offline aplikácie a následne vytvoriť webový frontend. Slovníky v aplikácií slúžia pre vývojárov spoločnosti Siemens s.r.o. na zjednodušenie práce na medzinárodných projektoch v cudzích jazykoch.
}
\thesislong{thanks}{
    Rád by som sa poďakoval Mgr. Jiřímu Ohnheiserovi za pomoc a užitočné rady pri vypracovaní diplomovej práce a mojej priateľke Nikole Mišíkovej za podporu počas písania práce.
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight Markup
\usepackage{listings}
\begin{document}
\chapter{Úvod}
Theses are rumoured to be the capstones of education, so I decided
to write one of my own. If all goes well, I will soon have a
diploma under my belt. Wish me luck!

\chapter{Slovník}
Táto kapitola sa zaoberá základnými princípmi práce so slovníkmi, ktoré sú uplatňované rovnako v desktopovej aj vo webovej aplikácií.

\section{Prípady použitia}
Slovník je súbor slov, z ktorých každé má priradený nejaký preklad. Preklad môžu tvoriť aj viaceré slová alebo slovné spojenia. Predpokladanou hlavnou rolou používajúcou slovník sú vývojári pracujúci so zdrojovými kódmi v nemeckom jazyku. Môžeme rozlíšiť dva hlavné prípady užitia - preklad a vykonávanie zmien v slovníkoch.

Preklad v slovníku funguje na princípe vyhľadávania slov v užívateľmi zvolených slovníkoch, pričom využíva porovnávanie na základne \textbf{Levenshteinovej vzdialenosti}. Užívateľ vie naraz prekladať viacero slov vďaka spracovaniu vstupu, ktorý zadal.

Užívateľ má možnosť spravovať slovníky, ktoré môže vytvárať, editovať a odstraňovať. V rámci editácie slovníkov môže pridávať, meniť a vymazávať jednotlivé slová alebo ich preklad.

\section{Spracovanie vstupu}
Jednou zo základných charakteristík funkcionality aplikácie je spracovanie textového vstupu na množinu slov, ktoré sa majú v slovníkoch vyhľadať. Základným predpokladom je preklad rôznych výrazov zo zdrových kódov, takže na vstupe sa môžu očakávať napríklad názvy premenných, rôzne skratky alebo aj celý riadok z kódu. 

Pri viacslovných pomenovaniach premenných alebo metód sa využívajú rôzne programátorské konvencie, napr. \textit{Camel Case} alebo \textit{Snake Case}, takže slovník poskytuje funkcionalitu pársovania takýchto slov a prekladá už priamo samotné rozpársované reťazce.

\section{Vyhľadávanie slov}
Vyhľadávanie slov v slovníku využíva porovnávanie hľadaného výrazu s každým slovom, je teda potrebné vždy prejsť celý slovník. Výstupom je množina slov, ktorá splňuje podmienku na zhodu s hľadaným slovom. Táto podmienka je daná zvolenou limitáciou výstupnej hodnoty, ktorú vypočítava Levenshteinova funkcia. Ak je výsledná hodnota menšia alebo rovná limitu, tak je slovo zaradené do množiny slov, ktorá sa zobrazí užívateľovi ako preklad.

Takéto vyhľadávanie zvyšuje pravdepodobnosť, že užívateľ nájde preklad, ktorý potrebuje. Môže sa totiž stať, že zadal slovo v nepresnom tvare, ktorý sa odlišuje od kľúčového slova v slovníku, či už mylne alebo preklepom v písaní.


\subsection{Levenshteinova vzdialenosť}
Pre každé slovo v slovníku sa vypočíta tzv. Levenshteinova vzdialenosť s daným slovom. Je implementovaná ako funkcia, ktorá má 2 vstupné parametre dátového typu reťazec a jej výstupom je číselná hodnota, ktorá určuje celkový počet znakov, o ktoré sa dané 2 reťazce líšia. Dá sa to popísať aj ako počet operácií s jednotlivými znakmi reťazca, ktoré je potrebné vykonať, aby bol zhodný s druhým reťazcom.

Medzi tieto operácie patrí pridanie, odobranie a zmena znanku za nejaký iný. Príklad týchto operácií môžeme vidieť na obrázku \ref{fig:levenshtein}. Nezáleží pri tom na tom, ktoré slovo máme editovať na ktoré, pretože znakové operácie sú symetrické. To znamená, že z ak máme operáciu pridania znaku do jedného slova, môžeme ju brať ako operáciu odstránenia znaku z druhého slova a pri editácií \textit{a} $\rightarrow$ \textit{b} môžeme opačne vykonať editáciu \textit{b} $\rightarrow$ \textit{a}. Minimálny počet operácií v zmene prvého slova na druhé teda ostáva rovnaký ako v zmene z druhého slova na prvé.

Táto metrika bola zavedená v roku 1965 ruským matematikom Vladimírom Levenshteinom a doteraz sa využíva na porovnávanie slov v rôznych oblastiach informatiky napríklad v algoritmoch na zisťovanie preklepov alebo pri optickom rozoznávaní znakov.

Ako príklad si zoberme slovo \textit{willkommen}, ktoré by bolo nájdené, aj keby bolo na vstup zadané slovo napríklad \textit{wilkomen}, pri ktorom je potrebné urobiť 2 znakové operácie, konkrétne pridanie znaku \textit{l} a \textit{m}. Ďalším príkladom môžu byť slová so špecifickými znakmi pre daný jazyk, konkrétne pre nemecký jazyk to sú znaky ako \textit{ß} alebo znaky s interpunkčnými znamienkami, napríklad \textit{ä} a \textit{ö}. Tieto znaky sa na bežnej anglickej alebo českej klávesnici ani nevyskytujú, takže požadované slová sú nájdené, aj keď je na vstupe slovo obsahujúce tieto znaky bez interpunkcie.

\begin{figure}
	\begin{center}
	\includegraphics[width=\textwidth]{img/distance.png}
	\end{center}
    \caption{Operácie nad znakmi v slove.}
	\label{fig:levenshtein}
\end{figure}

\subsection{Algoritmus výpočtu Levenshteinovej vzdialenosti}
Základom algoritmu je matica \textit{n + 1} x \textit{m + 1}, pričom \textit{n} je dĺžka prvého slova a \textit{m} je dĺžka druhého slova. S využitím princípu dynamického programovania sa porovnávajú jednotlivé kombinácie prefixov obidvoch slov. Matica má tak naviac jeden riadok a jeden stĺpec, ktoré predstavujú prázdny prefix.

Hlavný problémom je teda určenie minimálnej vzdialenosti - \texttt{D[m,n]}, ktorý je možné rozdeliť na podproblémy tak, že sa určí minimálna vzdialenosť jednotlivých prefixov - \texttt{D[i,j]}, kde \texttt{i} a \texttt{j} sú dĺžky daných prefixov. Matica sa na začiatku inicializuje hodnotami podľa pravidiel \texttt{D[i,0] = i} a \texttt{D[0,j] = 0}. Ďalšie hodnoty sa vypočítajú na základe nasledujúceho vzorca, kde $a_i$ a $b_j$ predstavujú prefixy slov $a$ a $b$:

 \begin{equation}
 \texttt{D[i,j] = min}\begin{cases}
       \texttt{D[i - 1][j - 1] + 1\textsubscript{$a_i \neq b_j$}} \\
       \texttt{D[i][j - 1] + 1} \\
       \texttt{D[i - 1][j] + 1}
       \end{cases}
 \end{equation}

V prvom prípade sa jedná o nahradenie znaku s pripočítaním 1, ak sú znaky na pozícii $a_i$ a $b_j$ rôzne. Ak nejaké dva prefixy $a_i-1$ a $b_j-1$ majú určitú editačnú vzdialenosť, tak pridaním rôznych znakov k obom prefixom tútu vzdialenosť zvýši o hodnotu 1, čo predstavuje práve substitúciu pridaných znakov. Ak sú znaky zhodné, potom substitúcia nie je potrebná, takže vzdialenosť sa nemení. 

V druhom prípade sa jedná o pridanie znaku do prefixu $a_i$ a v treťom prípade sa jedná o odobratie znaku z prefixu $a_i$. Po vypočítaní všetkých hodnôt v matici nám vyjde výsledná hodnota práve na pozícii $[m,n]$.



\chapter{Server}
V tejto kapitole sa zaoberám serverom, ktorý slúži ako backend pre webového klienta aj pre desktopovú aplikáciu. Pre webového klienta backend poskytuje služby na prácu s dátami, ktoré predstavujú samotné slovníky, ďalej poskytuje preklad slov z vybraných slovníkov. Pre desktopovú aplikáciu poskytuje služby na synchronizáciu slovníkov.

\section{Použité technológie}
Server je implementovaný v programovacom jazyku Javascript s využitím frameworku Node.js.

\subsection{Node.js}
Technológií pre implementáciu serveru je mnoho a ešte pred začiatkom implementácie sa bolo nutné rozhodnúť, ktorú zvoliť. Node.js je pomerne celkom nová technológia, vznikla v roku 2009, avšak odvtedy postupne získavala čoraz viac na popularite.

Hlavnou myšlienkou vzniku bolo využitie Javascriptu aj na strane serveru a aj vďaka tomu si Node.js obľúbilo mnoho programátorv, ktorí mali skúsenosti prevažne so skriptovaním na strane klienta práve v tomto jazyku. Ďalšou výhodou bola možnosť využívať aj množstvo javascriptových knižníc, ktoré bolo veľmi jednoduché do aplikácie v Node.js naimportovať. Neskôr však vznikol nástroj na inštalácie externýhc knižních nazvaný Node Package Manager (NPM).

Základom Node.js je V8 javascriptový interpreter pre Google Chrome. Je založený na asynchrónnom spracovaní udalostí, takže napríklad nevznikajú blokujúce I/O procesy, medzi ktoré patrí prístup k súborom na disku alebo k sieťovým funkciam. Node.js obsahuje rôzne štandardné knižnice, medzi ktoré patrí napríklad File System pre správu súborov alebo HTTP pre správu požiadavkov.

Výhodou použitia Node.js je jeho jednoduchosť a hodí sa skôr pre menej rozsiahle aplikácie. Práve takáto je však aj táto slovníková aplikácia, ktorá pracuje s malým množstvom dát a nevyžaduje príliš komplexnú funkcionalitu. Zvoli som Node.js najmä preto a ešte aj kvôli mojim skúsenostiam s Javascriptom.

\subsection{Node Package Manager}
NPM je najznámejší a najpoužívanejší nástroj pre správu javascriptových externých knižníc, či už na strane klienta s využitím rôznych komplexnejších frameworkov alebo na strane serveru využívajúceho Node.js. Pomocou neho sa dajú stiahnuť a zároveň nainštalovať požadované knižnice jednoducho zadaním príkazu \texttt{npm install} nasledovaného názvom knižnice. Tieto knižnice môže vytvárať ktorýkoľvek programátor alebo programátori a keď ich oficiálne publikujú, tak si ich môže ktokoľvek nainštalovať a začať používať. Vďaka tomu existuje obrovské množstvo takýchto knižníc.

Konfiguračným súborom je \texttt{package.json}, v ktorom je zoznam použitých knižních, ktoré sa všetky stiahnu a nainštalujú príkazom \texttt{npm install} a následne je aplikácia už pripravená na spustenie. V \texttt{package.json} sa nachádza aj zoznam skriptov, ktoré je potom možné spustiť príkazom \texttt{npm} nasledovaným názvom skriptu.

Knižnice môžu mať tiež svoj vlastný \texttt{package.json}, v ktorom sa nachádza zoznam ďalších knižníc, ktoré samotná knižnica využíva. Pri inštalácií sa vytvorí priečinok \texttt{node\_modules} obsahujúci jednotlivé knižnice a zároveň aj knižnice nainštalované ako ich závislosti.

\subsection{Koa}
Koa je jeden z frameworkov pre Node.js slúžiaci pre vývoj webových aplikácií. Je to pomerne málo rozsiahla knižnica s jednoduchou funkcionalitou, ale umožňuje rôzne rozšírenia o ďalšie frameworky a to formou funkcií, ktoré fungujú ako middleware. 

V aplikácií sa na začiatku vytvorí objekt obsahujúci metódu \texttt{use}, ktorej parametrom je asynchrónna funkcia - middleware. Tá ma dva vstupné parametre. Prvým z nich je objekt predstavujúci kontext HTTP požiadavku (\texttt{ctx}) a druhým je asynchrónna funkcia (\texttt{next}), ktorá spúšťa ďalší middleware.

\paragraph{Kontext požiadavku}
Kontext obsahuje pod atribútom \texttt{ctx.request} všetky parametre požiadavku prijatého na server, napríklad hlavičky, typ HTTP metódy alebo telo požiadavku. Zároveň je možné nastavovať parametre odpovede, ktorú server bude odosielať, napríklad \texttt{ctx.body} nastaví telo alebo \texttt{ctx.status} nastaví status kód.

\paragraph{Koa middleware}
Na obrázku \ref{fig:koa-middleware} je sekvenčný diagram, v ktorom je znázornené poradie vykonávania jednotlivých middlewarov. To je určené tak, v akom poradí sa zavolajú jednotlivé middleware-y metódou \texttt{use}. Vo funkcii predstavujúcej middleware je možné použiť \texttt{await} pred príkazom 
\texttt{next} a zvyšok príkazov sa tak vykoná až po skončení nasledujúceho middleware-u.


\begin{figure}
	\begin{center}
	\includegraphics[width=\textwidth]{img/koa-middleware.png}
	\end{center}
    \caption{Koa middleware}
	\label{fig:koa-middleware}
\end{figure}


\section{Architektúra}
Server je implementovaný v programovacom jazyku Javascript s využitím frameworku Node.js. Poskytuje endpointy pre požiadavky na základe protokolu HTTP. V nasledujúcich podkapitolách popisujem základné prvky a návrhové vzory, ktoré server využíva.

\subsection{Aplikačné vrstvy}
Často sa v serverových ale aj iných aplikáciach využíva rozdelenie funkcionality na rôzne vrstvy. Môžu to byť konkrétne návrhové vzory, napríklad Facade layer alebo Service layer, z ktorý každá vykonáva špecifickú funkcionalitu. Takéto vrstvy majú komunikovať len so susednými vrstvami. V aplikácií nevyužívam konkrétne návrhové vzory, ale funkcionalita je rozdelená do troch vrstiev.

V najvyššej vrstve sa spracovávajú požiadavky, ktoré prichádzajú na server. Validujú sa parametre požiadavkov vytvárajú sa odpovede na ne (HTTP-response). Táto vrstva komunikuje s prostrednou vrstvou volaním jej metód. Má na starosti zavolanie metódy so správnymi argumentmi a následné spracovanie výstupu danej metódy, na základe ktorého potom daný HTTP-response tvorí.

Prostredná vrstva predstavuje aplikačnú logiku. Na základe argumentov, ktoré dostane, vykoná špecifickú funkcionalitu. K tej potrebuje samotné dáta a aby ich získala, využíva poslednú, najnižsiu vrstvu. Príkladom funkcionality môže byť vyhľadávanie slov v slovníkoch. Výsledky potom vracia najvyššej vrstve, prípadne sa môže jednať aj o chybové stavy.

\subsection{Client–server model}
Princíp modelu client-server je, že proces, ktorý predstavuje server, spracováva požiadavky prichádzajúce od viacerých klientov. Server posiela potom dáta naspäť klientom, u ktorých sa zobrazujú.

Pri toku dát zo servera ku klientovi sa však zvyčajne vykonáva určitá logika. Tá predstavuje rôzne spracovanie dát od filtrovania cez usporiadavanie až po formátovanie. Ďalej je potrebné dáta transformovať do formátu HTML, ktorý je určený pre zobrazovanie v internetových prehliadačoch. Pri opačnom toku dát - od klienta na server, je nutné spracovať akcie, ktoré užívatelia vykonávajú.

Táto logika môže byť vykonávaná aj na strane serveru a aj na strane klienta a podla toho sa aj rozlišujú modely \textit{Thin Client} a \textit{Thick Client}. V prípade modelu \textit{Thin Client} sa väčšina logiky vykonáva na strane serveru, v pripade modelu \textit{Thick Client} je veľká časť logiky presunutá na stranu klienta.

Ja som sa snažil väčšiu časť tejto logiky preniesť práve na stranu klienta. Server teda vytvára odpoveď len vo formáte JSON, ktorú následne webový klient spracuje a vytvára zodpovedajúci HTML kód. Užívateľské akcie sú spracovávané na klientovi, ktorý posiela zodpovedajúce požiadavky serveru buď na čítanie alebo zapisovanie dát.

\subsection{REST API}
Pri vytváraní jednotlivých endpointov som využil princípov architektúry REST (Representational State Transfer). Je to architektúra na jednotný prístup k dátam aplikácie alebo k procedúram s dátami. Každá dátová entita má svoj jedinečný indentifikátor označovaný ako URI (Uniform Resource Identifier).

Táto architektúra umožňuje pristupovať k zdrojom pomocou metód protokolu HTTP a využíva z nich tieto štyri:
\begin{itemize}
	\item \texttt{GET} na získanie prístupu k dátam
	\item \texttt{POST} na vytvorenie nových dát
	\item \texttt{PUT} na editáciu existujúcich dát
    \item \texttt{DELETE} na vymazanie dát
\end{itemize}

Základnou entitou sú slovníky a všetky služby týkajúce sa práce s nimi začínajú prefixom \texttt{/dictionary}. Služby súvisiace s prácou s konkrétnym slovníkom potom majú prefix \texttt{/dictionary/:name}. Ďalej existujú služby na prácu so slovami v slovníku, tie majú prefix \texttt{/dictionary/:name/word}. Podrobný popis služieb sa nachádza v kapitole \ref{sec:api}.

V tejto aplikácií sú všetky odosielané aj prijímané dáta vo formáte JSON, pretože je kompaktnejší, prehľadnejší a najmä je to natívny formát jazyku Javascript, v ktorom je napísaný aj server aj klient.


\section{Popis služieb API} \label{sec:api}

\texttt{GET api/version}
\begin{itemize}
\item Vráti názov a verziu aplikácie a slúži pre desktopového klienta ako overenie, že komunikuje so správnym serverom
\item \begin{lstlisting}[basicstyle=\small]
Response body:
{
  "app":"dictionaryServer",
  "version":"0.0.0"
}
\end{lstlisting}
\end{itemize}

\noindent
\texttt{GET api/dictionary}
\begin{itemize}
\item Vráti zoznam všetkých slovníkov s ich základnými parametrami, takže neobsahujú slová s prekladmi
\item \begin{lstlisting}[basicstyle=\small]
Response body:
[
  {
  	"name": "dictionary1",
  	"revision": 47,
    "wordCount": 42,
    "createdAt": 6548745546,
    "lastEditedAt": 7984641681,
  },
  ...
]
\end{lstlisting}
\end{itemize}

\noindent
\texttt{POST api/dictionary}
\begin{itemize}
\item Vytvorí nový slovník a vráti číslo jeho revízie
\item Parameter \texttt{name} predstavuje meno slovníka a parameter \texttt{text} predstavuje text slov s prekladmi v rovnakom formáte ako v súboroch \texttt{.dict}
\item \begin{lstlisting}[basicstyle=\small]
Request body:
{
  "name": "dictionary1",
  "text": "ein\n one\nzwei\n zwei\ndrei\n three"
}
\end{lstlisting}
\end{itemize}

\noindent
\texttt{GET api/dictionary/:name?json}
\begin{itemize}
\item Vráti celý obsah slovníku s menom \texttt{name} a v prípade prítomnosti parametru \texttt{json} (napríklad \texttt{json=true}) sú slová vo formáte JSON, v opačnom prípade sú v textovom formáte DICT
\item 
\item \begin{lstlisting}[basicstyle=\small]
Response body (words in JSON):
{
  "name": "string",
  "revision": int,
  ...
  "words": {
  	"word1": "translation1",
    "word2": "translation2",
    ...
  }
}
\end{lstlisting}
\item \begin{lstlisting}[basicstyle=\small]
Response body (words in DICT):
{
  "name": "string",
  ...
  "text": "ein\n one\nzwei\n zwei\ndrei\n three"
}
\end{lstlisting}
\end{itemize}

\noindent
\texttt{DELETE api/dictionary/:name}
\begin{itemize}
\item Vráti názov a verziu aplikácie a slúži pre desktopového klienta ako overenie, že komunikuje so správnym serverom
\item \begin{lstlisting}[basicstyle=\small]
Response body:
{
  "app":"dictionaryServer",
  "version":"0.0.0"
}
\end{lstlisting}
\end{itemize}

\noindent
\texttt{POST api/dictionary/:name/word/}
\begin{itemize}
\item Vráti názov a verziu aplikácie a slúži pre desktopového klienta ako overenie, že komunikuje so správnym serverom
\item \begin{lstlisting}[basicstyle=\small]
Response body:
{
  "app":"dictionaryServer",
  "version":"0.0.0"
}
\end{lstlisting}
\end{itemize}

\noindent
\texttt{PUT api/dictionary/:name/word/}
\begin{itemize}
\item Vráti názov a verziu aplikácie a slúži pre desktopového klienta ako overenie, že komunikuje so správnym serverom
\item \begin{lstlisting}[basicstyle=\small]
Response body:
{
  "app":"dictionaryServer",
  "version":"0.0.0"
}
\end{lstlisting}
\end{itemize}

\noindent
\texttt{DELETE api/dictionary/:name/word/}
\begin{itemize}
\item Vráti názov a verziu aplikácie a slúži pre desktopového klienta ako overenie, že komunikuje so správnym serverom
\item \begin{lstlisting}[basicstyle=\small]
Response body:
{
  "app":"dictionaryServer",
  "version":"0.0.0"
}
\end{lstlisting}
\end{itemize}

\noindent
\texttt{POST api/sync/dictionary/:name}
\begin{itemize}
\item Služba slúži pre synchronizáciu slovníka desktopového klienta so slovníkom na serveri.
\item Server dostáva zmeny z desktopového klienta a zároveň mu posiela vlastné zmeny.
\item \begin{lstlisting}[basicstyle=\small]
Request body:
{
  "revision": 5,
  "changes": [
    {
      "type": "add",
      "word": "word1",
      "translation": "translation1"
    },
    ...
  ]
}
\end{lstlisting}
\item \begin{lstlisting}[basicstyle=\small]
Response body:
{
  "revision": 5,
  "changes": [
    {
      "type": "add",
      "word": "word1",
      "translation": "translation1"
    },
    ...
  ]
}
\end{lstlisting}
\end{itemize}

\noindent
\texttt{GET api/translate?word\&dict}
\begin{itemize}
\item Vráti zoznam prekladov k danému slovu z parametra \texttt{word}, ktoré hľadá v slovníkoch uvedených vo viacnásobných parametroch \texttt{dict}.
\item Parameter \texttt{word} môže byť reťazec viacerych slov, ktoré sa následne rozpársujú na jednotlivé slová pre vyhľadávanie prekladov.
\item Ak nie je prítomný žiadny parameter \texttt{dict}, preklady sa vyhľadávajú vo všetkých dostupných slovníkoch.
\item Preklad obsahuje vyhľadávané slovo \texttt{key}, slovo ktoré sa našlo v slovníku (\texttt{word}), jeho preklad (\texttt{translation}), Levenshteinovu vzdialenosť medzi vyhľadávaným a nájdeným slovom (\texttt{distance}) a slovník, v ktorom bolo slovo nájdené (\texttt{dict}).
\item \begin{lstlisting}[basicstyle=\small]
Response body:
[
  {
    "word": "word1",
    "key": "word",
    "translation": "translation1",
    "distance": 1,
    "dict": "dictionary1"
  },
  {
    "word": "word2",
    "key": "word",
    "translation": "translation2",
    "distance": 1,
    "dict": "dictionary2"
  },
  ...
]
\end{lstlisting}
\end{itemize}


\section{Ukladanie dát}
V desktopovej aplikácií sú slovníky uložené v textových súboroch vo formáte \texttt{.dict}. Každé slovo je na samostatnom riadku a k nemu priradený preklad je na novom riadku pod daným slovom a začína medzerou. Preklad môže tvoriť aj viacero slov, tie sú všetky na jednom riadku oddelené znakom \texttt{;}. Slovník sa do desktopovej aplikácie načíta zo súboru a je uložený v pamäti ako reťazec (\texttt{std::string}).

\theoremstyle{definition}
\newtheorem{exmp}{Príklad}[chapter]
\begin{exmp}
Formát slovníku
\centering
\begin{lstlisting}[basicstyle=\small]
sprechen
 speak; talk
reisen
 travel
einmal
 once; one day
\end{lstlisting}
\end{exmp}

Na uloženie slovníku však existuje viacero možností. Medzi klasickú voľbu pri implementácií serverových aplikácií patrí napríklad SQL, prípadne NoSQL databáza. Databáza je ale vhodná na ukladanie komplexnejších entít a v prípade slovníku sa jedná o jednoduchú entitu. Navyše pri dotazovaní na dáta kvôli prekladu je vždy potrebný celý slovník, preto je vhodné mať stále v pamäti. Serverová aplikácia tak používa in-memory databázu na prácu s dátami a na permanentné uloženie využíva súbory.

\subsection{In-memory databáza}
Server má v pamäti uložené slovníký ako objekt, ktorý funguje ako hash mapa. V Javascripte, konkrétne v engine V8, je implementovaný objekt ako pole, v ktorom sú kľúče objektu pomocou nejakej hashovacej funkcie mapované na indexy pola. Prístup na takýto prvok cez kľúč je konštantný. Slová slovníku je možné uložiť ako pár kľúč-hodnota, pričom kľúčom je samotné slovo a hodnotu predstavuje jeho preklad.

\begin{exmp}
Štruktúra slov slovníku v pamäti
\centering
\begin{lstlisting}[basicstyle=\small]
{
  "sprechen": "speak; talk",
  "reisen": "travel",
  "einmal": "once; one day"
}
\end{lstlisting}
\end{exmp}

\subsection{String vs. Hash map}
Pre porovnanie dátovej štruktúry reťazca a hash mapy boli vytvorené testy, v ktorých sa vyhľadávala skupina slov v jednotlivých štruktúrach a pri vyhľadávaní sa vypočítavala Levenshteinova vzdialenosť. Testovacie dáta predstavoval slovník s počtom slov 81472. V ňom boli vyhľadávané 4 slová, konkrétne \textit{schwimmen, willkommen, katze} a \textit{grose}. Pre obe štruktúry boli zmerané počty milisekúnd, ktoré predstavujú časovú zložitosť prehľadávania danej štruktúry.

Prehľadávanie hash mapy si vyžaduje iteráciu cez jednotlivé kľúče, prehľadávanie reťazca si vyžaduje iteráciu cez jednotlivé znaky v reťazci. Tých je síce oveľa viac ako kľúčov, ale pri hash mape je nutné ich mapovanie na položky v poli. Výsledkom je teda mierne efektívnejšie prehľadávanie práve v hash mape, ako znázorňuje tabuľka \ref{tab:string-hash}.

Ďalším zaujímavým parametrom je využitie operačnej pamäte. Hash mapa jej využíva podstatne viac ako reťazec, kedže potrebuje mať popri samotných slovách a prekladoch uložených aj množstvo referencií a ďalších atribútov. V tabuľke sú dáta po načítaní rovnakého slovníku ako použitom pri testovaní vyhľadávania.

Dôvodom pre použitie hash mapy miesto reťazca bol konštantný prístup k jednotlivým slovám. V reťazci by bolo potrebné vždy prechádzať slovník, aby bolo možné slovo nájsť. Takýto prístup ku konkrétnemu slovu je nutný pri operáciach so slovami, akými sú pridanie, editácia a zmazanie slova. Ďalším dôvodom bolo to, že hash mapa už má slová a ich preklady rozpársované a tak sa jednoduchšie pracuje s takouto štruktúrou, ako s celým reťazcom. 

\begin{table}[]
\centering
\caption{String vs. Hash map}
\label{tab:string-hash}
\begin{tabular}{lll}
     & Hash map & String   \\
Time & 640 ms   & 820 ms   \\
Memory used & 23 773 kB & 12 027 kB
\end{tabular}
\end{table}

\subsection{JSON súbor}
Každý slovník je uložený v samostatnom súbore vo formáte JSON. Pre Javascript je to prirodzený formát a je jednoduché takéto súbory pársovať do objektu, pretože je to natívna funkcionalita metódy \texttt{require}, ktorá slúži na importovanie Javascriptových súborov a modulov. Navyše formát JSON presne popisuje štruktúru objektov v Javascripte.


\section{Implementácia}
\subsection{Asynchrónne metódy}
V prvotných verziach Node.js boli udalosti, ktoré sa volali po skončení asynchrónnej metódy, implementované pomocou funkcií (zvaných callback), ktoré boli predané ako parametre do danej metódy. S príchodom ECMA Scriptu 2015 sa začali tieto funkcie nahradzovať Promisami. Tie už neboli parametrom asynchrónnej metódy, ale jej výstupnou hodnotou. Promisa obsahuje metódu \texttt{then}, ktorej parametrom je callback po úspešnom skončení Promisy, ďalej metódu \texttt{catch}, ktorej parametrom je callback pre chybový stav v Promise.

ECMA Script 2016 priniesol do Javascriptu kľúčové slová \texttt{async} a \texttt{await}, ktoré sú podporované v Node.js od verzie 7.6 a sú použité v implementácii serveru slovníkovej aplikácie. Stále sa využívajú Promisy a \texttt{await} je iba syntakticky inak napísaný \texttt{then}, avšak prináša prehľadnejšiu štruktúru kódu.

Úplne prvou asynchrónnou metódou po spustení programu je práve spustenie servera. Na to slúži metóda \texttt{listen} z frameworku Koa. Pri spracovaní HTTP požiadavkov sa tieto asynchrónne metódy využívajú, čo znamená, že sa dva rôzne požiadavky môžu spracovávať paralérne. Výhodou toho je, že na začatie spracovávania jedného požiadavku nie je potrebné, aby sa spracovávanie druhého pred tým ukončilo.

\subsection{Routing}
Pre identifikáciu API služieb bol použitý modul \texttt{koa-router}, ktorý funguje ako middleware pre modul \texttt{koa}. Každé spracovanie API služby funguje ako samostatný middleware. Každý middleware porovnáva URL a HTTP metódu a podľa nich buď začne vykonávať kód určený pre danú službu alebo len zavolá ďalší middleware v poradí.

Na začiatku sa vytvorí objekt \texttt{router}, ktorý obsahuje metódy s názvami zhodnými s názvami klasických HTTP metód. Tie majú ako prvý parameter URL, podľa ktorého je spolu s názvom danej metódy možná identifikácia konkrétnej služby. Spracovanie napríklad služby \texttt{GET api/dictionary/:name} môže vyzerať nasledovne:

\begin{exmp}
Spracovanie HTTP požiadavku
\centering
\begin{lstlisting}[basicstyle=\small]
router.get('/dictionary/:name', async (ctx, next) => {
  const name = ctx.params.name
  const dict = DictController.findDictionary(name)
  
  ctx.body = dict
})
\end{lstlisting}
\end{exmp}

Ak je prefix \texttt{api/} nastavený v počiatočnej konfigurácií routra, tak sú všetky služby spracovávané spolu s týmto prefixom. Nie je teda potrebné ho písať do URL v každej metóde. Výhodou je aj možnosť tento prefix zmeniť kedykoľvek pre všetky metódy naraz.

Koa-router má aj klasickú metódu \texttt{use}, ktorá funguje rovnako ako \texttt{use} priamo v Koa, takže je možné pridávať middleware-y takým istým spôsobom.

\subsection{Validácia HTTP požiadavkov}
Pri HTTP požiadavku je možné validovať viacero druhov parametrov. REST API serveru využíva parametre URL pre identifikáciu zdrojov, ďalej využíva parametre z \textit{query} časti URL a využíva aj telo požiadavkov - \textit{Request body}. Na ich validáciu je použitá knižnica Koa-validate, ktorá rozširuje framework Koa. Konkrétne pridáva priamo do objektu \textit{ctx} validačné metódy, ktoré potom vytvoria aj relevantnú HTTP odpoveď v podobe chybových hlášok o vyskytnutých chybách (\texttt{ctx.errors}).

Pre identifikáciu konkrétneho parametra sa používajú tri základné metódy. Konkrétne \texttt{checkParams("url-param")} pre identifikáciu základných parametrov URL, \texttt{checkQuery("queryParam")} pre identifikáciu \textit{query} časti URL a \texttt{checkBody("bodyParam")} pre identifikáciu parametrov \textit{Request body}.

Na spomenuté metódy je potom možné reťaziť validačné metódy, ktoré validujú daný parameter. Umožňujú validovať typ parametra (\texttt{isInt()}), či je prítomný, respektíve či nie je prázdny (\texttt{notEmpty()}) a umožňujú validovať nejaké jeho vlastnosti, napríklad pomocou regulárneho výrazu (\texttt{match()}, prípadne \texttt{notMatch()}).

Validácia \texttt{notEmpty()} sa využíva hlavne v požiadavkoch typu POST a PUT pre zistenie, či sú prítomné povinné dáta pre vytvorenie, prípadne editáciu. Napríklad pri vytvorení alebo editácii slova musí byť prítomné vždy dané slovo aj jeho preklad. 

Pri názvoch slovníkov existuje obmedzenie na niektoré znaky kvôli tomu, že daný názov sa používa aj pre názov príslučných súborov, ktoré by tak nebolo možné vytvoriť v závislosti od používaného operačného systému. Pri zjednotení týchto znakov dostávame množinu znakov $\slash  <  >  *  ?  \backslash  \%  .  :  "  |$

Pri konkrétnych slovách je tiež obmedzenie na špecifické znaky, pretože slovo by malo pozostávať hlavne z písmen a navyše pri prístupe k týmto slovám v Lowdb pomocou metód \texttt{get} a \texttt{set} by niektoré znaky mohli byť brané ako kľúčové znaky pre prístup k ďalším atribútom objektu............

\subsection{Error handling}

\subsection{Databáza}
Uloženie dát je rozdelené do dvoch sekcií - operačná pamäť a súbory typu JSON, ktoré má daný slovník dva - jeden pre ukladanie slov a druhý pre ukladanie zmien nad týmito slovami. Pri zmene dát v slovníku je nutné uložiť túto zmenu aj do príslušných súborov, na to je použitá Javascriptová knižnica Lowdb. Je to veľmi jednoduchá knižnica, ktorá funguje ako súborová databáza určená na prácu so súbormi typu JSON, ale podporuje aj ďalšie formáty, napríklad BSON alebo XML.

Lowdb umožňuje ukladanie dát do klasického javascriptového objektu (spomínana hash mapa z kapitoly blabla. Pri spustení aplikácie je vytvorený objekt zavolaním \texttt{lowdb('path/to/file.json)} s parametrom cesty k danému súboru. V zložke \texttt{dictionaries} sa nachádzajú súbory s názvom slovníku a v zložke \texttt{meta} sa nachádzajú súbory pre ukladanie zmien s názvom slovníku doplneným prefixom \texttt{\_} (napr. \_dictName.json). Pre každý súbor je tak vytvorený samostatný Lowdb objekt.

Ten obsahuje metódy na prístup k atribútom objektu, napríklad \texttt{get()} na získanie hodnoty a \texttt{set()} na zapísanie hodnoty. Parametrom obidvoch metód je názov atribútu, ktorý predstavuje kľúč v hash mape a metóda \texttt{set} má ako parameter navyše ešte hodnotu, ktorú zapisuje.

Lowdb poskytuje okrem metód \texttt{get} a \texttt{set} aj množstvo ďalších a to konkrétne metódy z knižnice Lodash. Tá obsahuje metódy pre prácu s javascriptovými kolekciami, ktoré sa dajú rovnako použiť pre dáta v Lowdb. Ďalšou dôležitou metódou je \texttt{write()}, ktorá vykonané zmeny uloží do súboru.

\subsection{Parsovanie}
Pri prekladaní slova pomocou služby \texttt{GET api/translate?word\&dict} sa v parametri \texttt{word} nachádza reťazec, ktorý môže obsahovať viacero slov. Tie sa parsujú z reťazca jednak podľa medzier, ktorými sú oddelené a navyše aj podľa špecifických znakov alebo vlastností určených na rozdelenie slov.

Na vyhľadanie týchto znakov sú použité regulárne výrazy a medzi potencionálne slová sa vloží medzera. Takéto rozdelenie umožnuje pomocou javascriptovej funkcie \texttt{String.prototype.split(' ')} vytvoriť pole slov, s ktorým je už jednoduché pracovať. Regulárne výrazy pre predpokladané programátorské menné konvecie sú nasledovné:
\\

\noindent
\texttt{/C[A-Z][a-z]+/g}
\begin{itemize}
\item Táto menná konvencia predpokladá výskyt veľkého písmena \textit{C} pred nejakým slovom zašínajúcim tiež veľkým písmenom a znamená označenie triedy (Class).
\item Príkladom z reťazca \texttt{CKreis} chceme dostať slovo \texttt{kreis}.
\end{itemize}

\noindent
\texttt{/[a-z][A-Z]/g}
\begin{itemize}
\item Určené pre parsovanie v prípade konvencie s názvom Camel case
\item Príkladom z reťazca \texttt{findeLetztenIndex} chceme dostať slová \texttt{finde}, \texttt{letzten} a \texttt{index}.
\end{itemize}

\noindent
\texttt{/[A-Z]{2,}/g}
\begin{itemize}
\item Detekcia konvencie Upper case, pri ktorej všetky písmená v slove sú veľké.
\item Príkladom z reťazca \texttt{undSCHNELL} chceme dostať slová \texttt{und} a \texttt{schnell}.
\end{itemize}

\noindent
\texttt{/\_/g}
\begin{itemize}
\item Detekcia konvencie Snake case, podľa ktorej sú slová oddelené znakom \_ (podtŕžnik).
\item Príkladom z reťazca \texttt{FILTER\_LEERE\_ELEMENTE} chceme dostať slová \texttt{filter}, \texttt{leere} a \texttt{elemente}.
\end{itemize}

Dôležité je aj poradie, v ktorých sa dané reguláre výrazy aplikujú. Napríklad parsovanie slov s prefixom \textit{C} prebieha ešte pred Upper case parsovaním, pretože potom by sa napríklad slovo \texttt{CKreis} rozdelilo na slová \texttt{CK} a \texttt{reis}.

Príkladom jedného vyhľadávania môže byť nasledovný reťazec: \texttt{CLesenFlauming\_falshGeshrieben word einfachUndSCHNELL}, ktorý sa rozparsuje na slová \texttt{lesen}, \texttt{flaumig}, \texttt{falsh}, \texttt{geschrieben}, \texttt{worte}, \texttt{einfach}, \texttt{und} a \texttt{schnell}. Pri jednom prekladaní sa tak všetky tieto slová vyhľadávajú zvlášť.

\subsection{Práca so slovníkom}
Prvým krokom v práci s nejakým slovníkom je jeho vytvorenie, to spočíva vo vytvorení dvoch súborov pomocou funkcie z Lowdb, ktorá zároveň vytvorí príslušné objekty v pamäti. Vytvorenie slovníku môže znamenať aj počiatočnú inicializáciu slov z prijatého textu, ktorý sa parsuje na základe formátu DICT.

Ďalšími funkciami pre prácu so slovníkom, konkrétne s jeho slovami, sú \texttt{addWord()} pre pridanie slova, \texttt{changeWord()} pre editáciu slova a \texttt{deleteWord()} pre jeho zmazanie. Tieto metódy sa vyskytujú vo vrstve aplikačnej logiky, aj v databázovej vrstve.

Pri metóde \texttt{addWord()} sa kontroluje, či dané slovo v slovníku už náhodou neexistuje, pretože ak áno, toto slovo sa nemôže vytvoriť. Neumožňuje to základný princíp hash mapy, ktorá môže obsahovať vždy maximálne jeden unikátny kľúč. V takom prípade sa preklad daného slova uloží k už existujúcemu slovu a rozšíri tak jeho preklad.

Pri rozšírení prekladu sa rozparsujú jednotlivé slová pôvodného aj nového prekladu podľa znaku bodkočiarka (;) a tie sa následne zlúčia do jedného reťazca, ale s vynechaním duplicít. Využité sú funkcie \texttt{String.prototype.split(';')} na vytvorenie pola slov, z ktorého sa odstraňujú duplicity a \texttt{Array.prototype.join('; ')} na zlúčenie slov naspäť do reťazca.

Takýto istý prípad môže nastať aj pri metóde \texttt{changeWord()}, ak sa zmení samotné slovo na nejaké nové, ktoré už slovník obsahuje. Vtedy sa preklady zlučujú rovnako. Metóda má nepovinný parameter \texttt{newWord}, ktorý, ak je prítomný, predstavuje zmenu slova a ak prítomný nie je, mení sa iba jeho preklad.

Na datábazovej vrstve sa využívaju Lowdb funkcie \texttt{set("key", "value")} a \texttt{unset("key")}. \texttt{Set} nastavuje slovu ("key") jeho preklad ("value") a \texttt{unset} vymaže slovo ("key") zo slovníka. Pridanie slova sa tak uskutočňuje zavolaním \texttt{set("word", "translation")}, ktoré využíva aj zmena slova, kedže \texttt{set} pôvodnú hodnotu prepíše novou hodnotou. Ak zmena slova zahŕňa aj zmenu na \texttt{newWord}, tak sa zavolá metóda \texttt{unset("word")}, kde parameter "word" predstavuje pôvodné slovo. Táto metóda sa rovnako volá aj pri vymazní slova.

\subsection{Použité knižnice}


\section{Synchronizácia slovníkov}
Úlohou servera je poskytovať cloudové úložisko dát, ktoré by mali byť dostupné pre desktopové aplikácie pre synchronizovanie jednotlivých slovníkov. Desktopový klient môže upravovať svoje dáta aj v offline režime a tieto zmeny si postupne ukladá. Klientov môže byť viacero a každý môže mať rôzne zmeny v svojich dátach. Synchronizáciou sa tak má umožniť, aby všetky zmeny od rozličných klientov sa ukladali na jedno miesto - server a mohli sa tak vykonané zmeny zdieľať medzi všetkými klientmi.

Pri synchronizácií slovníkov je požadovaným výstupným stavom ten, pri ktorom majú slovníky v rôznych klientoch rovnaké dáta. Ideálnym stavom je taktiež, ak sa čo najviac dát zachová, ale to nie je možné vždy dosiahnuť, kedže v zmenách môžu nastať konflikty. Dáta, ktoré sa nijakým spôsobom nemenili, musia zostať taktiež zachované.

Iniciátorom synchronizácie je desktopový klient, ktorá využíva službu servera \texttt{POST api/sync/dictionary/:name}. Zavolaním tejto služby klient posiela svoje zmeny spolu s revíziou slovníku. Služba synchronizuje vždy práve jeden slovník, ktorý je daný parametrom \texttt{name}. Server prijaté zmeny spracuje a zároveň posiela klientovi svoje zmeny, ktoré ešte klient nemá podľa revízie slovníku. V HTTP požiadavku sa teda nachádzajú zmeny klienta a v odpovedi naň sa nachádzajú zmeny serveru.

\subsection{Revízia slovníku}
Revízia je číslo, ktoré určuje aktuálnosť daného slovníku a slúži na identifikáciu nových zmien pre server. Počiatočná revízia pri vytvorení slovníku na serveri je 1 a pri pridávaní nových zmien sa postupne zvyšuje s každou zmenou o hodnotu 1. Pri synchronizácií sa aktuálna revízia posiela klientovi, ktorý si danú hodnotu udržuje až po ďalšiu synchronizáciu. Čím väčší je teda rozdiel medzi revíziami servera aj klienta, tak tým viac zmien klientovi chýba a tým viac je jeho verzia slovníku staršia.

Pri synchronizácií sa na serveri nájdu všetky zmeny, ktoré majú vyššiu hodnotu svojej revízie ako revízia klienta. Tieto zmeny sú nové a môžu pochádzať buď od jedného alebo aj viacerych desktopových klientov, ale aj od webových klientov. Všetky ich je však potrebné poslať klientovi, ktorý si slovník synchronizuje.

Server si ukladá len určitý počet zmien a tak sa môže stať, že nejaký klient má staršiu revíziu, ako je najstaršia revízia uložená na serveri. Vtedy je potrebné poslať klientovi celý obsah slovníku miesto zmien.

\subsection{Ukladanie zmien}
Zmeny sa ukladajú vo forme operácií nad slovami v slovníkoch, ktorými sú \textit{addWord}, \textit{changeWord} a \textit{deleteWord}. S každou operáciou sa uloží do súboru objekt reprezentujúci zmenu vo formáte JSON a pridá sa tak na koniec pola zmien. Jeho štruktúru tvoria atribúty \texttt{revision} a \texttt{changes}, ako môžeme vidieť na príklade \ref{exmp:metafile}. Každej jednej zmenej je tak priradená revízia, ktorá sa s každou ďalšou zmenou zvyšuje.

\begin{exmp}
\label{exmp:metafile}
Štruktúra zmien slovníku
\centering
\begin{lstlisting}[basicstyle=\small]
"revisions": [
  {
    "revision": 1,
    "changes": null
  },
  {
    "revision": 2,
    "changes": {
      "type": "add",
      "word": "ein",
      "translation": "one"
    }
  },
  {
    "revision": 3,
    "changes": {
      "type": "delete",
      "word": "ein"
    }
  },
  ...
]
\end{lstlisting}
\end{exmp}

Atribút \texttt{type} objektu \texttt{changes} označuje typ zmeny, ale na rozdiel od troch typov operácií nad slovníkom, existujú iba dva typy zmien - \texttt{add} a \texttt{delete}. Typ \texttt{add} predstavuje operáciu \textit{addWord}, typ \texttt{delete} predstavuje operáciu \textit{deleteWord} a operácia \textit{changeWord} je reprezentovaná dvoma zmenami ako typ \texttt{delete} nasledovaný typom \texttt{add}.

Počiatočná konfigurácia súboru zmien pri vytvorení slovníku je pole s objektom s atribútmi \texttt{"revision": 1} a \texttt{"changes": null}. Pri vytvorení slovníku v desktopovej aplikácií je počiatočná revízia nulová, takže je možné podľa toho zistiť, že daný slovník ešte nebol synchronizovaný so serverom ani raz. To zabraňuje synchronizácii dvoch rôznych slovníkov s rovnakým názvom.

\subsection{Spracovanie zmien}
Spracovanie je proces na serveri, pri ktorom sa aplikujú prijaté zmeny na daný slovník a zároveň sa vyhľadajú zmeny, ktoré treba poslať klientovi. Server prijaté zmeny prechádza a podľa typu operácie volá metódy \textit{addWord} a \textit{deleteWord} rovnako, ako keby dostal HTTP-request na služby pre pridanie alebo zmazanie slova.

Odoslané zmeny klient aplikuje rovnakým spôsobom, ale ak sa nejaká z prijatých týka rovnakého slova ako nejaká z odosielaných, tak by mohol byt porušený základný princíp synchronizácie, ktorým je konzistentnosť slovníkov. Príkladom môže byť zmena prekladu slova \textit{wort}, ktorá prišla od klienta a zmazanie slova \textit{wort}, ktoré je na serveri. Po aplikácii zmien by tak na serveri malo byť slovo \textit{wort} a na klientovi by byť nemalo.

Prijaté zmeny je potrebné aplikovať tak, aby konečný stav slovníku odpovedal stavu slovníku na klientovi po odoslaní zmien. Preto je potrebné vyriešiť potencionálne konflikty, ktoré môžu nastať pri rôznych zmenách na rovnakom slove. Rozdelenie operácie \textit{changeWord} na zmeny typu \texttt{add} a \texttt{delete} tento problém značne uľahčuje, pretože je tak jednoduchšie identifikovať zmeny pre konkrétne slovo, keďže \textit{changeWord} sa môže týkať až dvoch slov, pokiaľ sa nemení len preklad, ale aj slovo na nejaké iné.

Ďalšou výhodou ukladania zmien len do dvoch typov je jednoznačnosť výskytu slov. Podľa typu sa dá určit, či sa slovo v slovníku vyskytuje alebo nie, stačí sa pozrieť na jeho poslednú zmenu. Jednotlivé zmeny je tak možné zredukovať v prípade, že určité slovo bolo zmenené viackrát za sebou a niektoré jeho uložené zmeny sa tak môžu opakovať alebo ich nie je potrebné na slovník aplikovať, pretože nejaké nasledujúce zmeny určia konečný stav slova bez ohľadu na predchádzajúce zmeny.

\subsection{Redukcia zmien}
Zmeny si vieme rozdeliť podľa konkrétnych slov, ktorých sa týkajú a pre každé slovo, vieme odstrániť jeho nepotrebné zmeny. Príkladom môže byť viacnásobné použitie operácie \textit{changeWord} na zmenu prekladu slova, pričom stačí aplikovať iba posledný výskyt tejto operácie, keďže slovo vždy vymaže a vytvorí nové spolu s novým prekladom a preklady vytvorené predtým už slovo obsahovať nebude.

Zmeny jedného slova si môžeme rozdeliť na tri prípady podľa ich postupnosti:
\begin{itemize}
\item $\texttt{add}_1$, $\texttt{add}_2$, ..., $\texttt{add}_n$ - postupnosť operácií zložená výhradne z typov \texttt{add}
\item ..., $\texttt{delete}_{m}$, $\texttt{add}_{m+1}$, ..., $\texttt{add}_n$ - postupnosť obsahujúca aspoň jednu operáciu \texttt{delete} nasledovanú aspoň jednou operáciou \texttt{add}
\item ..., $\texttt{delete}_{n}$ - postupnosť, ktorej posledná operácia je \texttt{delete}
\end{itemize}

V prvom prípade sa jedná o pridanie slova, ktoré môže byť viacnásobne, takže pribúdajú nové preklady. Ak slovník slovo už obsahoval, všetky pôvodné preklady sa zachovávajú. V prípade výskytu \texttt{delete} a ukončením postupnosti operáciou \texttt{add} sa pôvodné preklady slova nazachovajú a vzniknú nové. Konkrétne sú to len tie, ktoré sa nachádzajú za poslednou operáciou \texttt{delete}, pretože všetky, ktoré boli pred ňou, budú tiež vymazané. V prípade, keď je \texttt{delete} poslednou operáciou v postupnosti, sa taktiež nezachovajú žiadne preklady a ani žiadne nepribudnú, pretože slovo sa zo slovníka vymaže úplne.

Odstránením všetkých zmien pred posledným výskytom zmeny \texttt{delete} sa zmeny dajú zredukovať. Ak medzi odstránenými je aj typ \texttt{delete}, tak to nevadí, pretože v konečnom stave sa slovo v slovníku vysk

\subsection{Konflikty}

\subsection{Odosielanie zmien}






\chapter{Webový klient}
Základom frontendu webových aplikácií sú technológie HTML a CSS, ktoré definujú, ako sa komponenty zobrazujú užívateľovi a programovací jazyk Javascript, ktorý vytvára logiku stránky, takže definuje funkcionalitu komponent. Existuje množstvo Javascriptových frameworkov pre tvorbu webu, medzi najpopulárnejšie v súčasnej dobe patrí AngularJS, React alebo Vue.js. Pre tvorbu tejto webovej aplikácie bol zvolený práve framework React.

\section{React}
React je framework určený pre tvorbu Single page aplikácií a bol vytvorený spoločnosťou Facebook. Zobrazuje tak práve jednu HTML stránku, ktorej obsah je dynamický, takže vytvára dojem, že stránky sa menia.

\subsection{JSX}
JSX je formát, ktorý rozširuje základnú syntax jazyku Javascript o elementy typické pre značkovacie jazyky ako HTML alebo XML. V Reacte sa miesto HTML používa práve JSX a výhodou je možnosť kombinovať Javascriptovú logiku s prezentačnými elementami v jednom súbore. Tieto súbory sa prekladajú do Javascriptu, pričom sú použité aj rôzne optimalizácie kódu.

Štruktúra JSX elementu je podobná štruktúre HTML elemntu, skladá sa z názvu, atribútov a obsahu, ktorý ohraničuje začiatočný a ukončovací tag. Takýto JSX element je možné ukladať do premenných, prípadne viacero elementov do poľa. Je možné vkladať dáta do elementov použitím priamo Javascriptového kódu. Dajú sa vytvárať vlastné komponenty zložené z viacerych elementov, ktoré potom odlišujú od natívnych elementov počiatočným veľkým písmenom v názve.

Na príklade blabla vidíme, že elementy sa používajú rovnako ako HTML elementy. Rozdielom je napríklad názvoslovie atribútov, v ktorom sa nepoužívajú pomlčky, ale Camel case a miesto atribútu \textit{class} je použitý \textit{className}, pretože \textit{class} je jedným z kľúčových slov v Javascripte. Javascriptový kód je možné vkladať do elementov pomocou znakov \texttt{\{} a \texttt{\}}.

\begin{exmp}
JSX štruktúra
\centering
\begin{lstlisting}[basicstyle=\small]
class Person extends React.Component {
  render () {
    return (
      <div className='person'>
        <p>{this.props.firstName}</p>
        <p>{this.props.lastName}</p>
      </div>
    )
  }
}

ReactDOM.render(
  <Person firstName='Peter' lastName='Parker' />,
  document.getElementById('root')
);
\end{lstlisting}
\end{exmp}

\subsection{Virtual DOM}
\textit{Document Object Model} (DOM) je štandardom W3C pre prístup a pracovanie s HTML elementami a definuje stromovú štruktúru elementov dokumentu. Najzložitejšou, respektíve najpomalšou časťou frontendovej logiky býva manipulácia s elementami DOM, ktorá je však nevyhnutná pri zmene zobrazovaných dát a prekleslovaní komponent dokumentu na obrazovku. Cieľom pre optimalizáciu je čo najmenej častá práca s týmito elementami.

React si vytvára popri štandardnom DOM objekte ešte takzvaný Virtual DOM, ktorý reprezentuje DOM elemety a ich štruktúru, takže je jeho kópiou. Práca s ním je však oveľa rýchlejšia, pretože neprebieha žiadne vykreslovanie tejto štruktúry. Pri zmene zobrazovaných dát alebo komponent sa vytvorí nový Virtual DOM objekt, ktorý sa porovná so svojou starou verziou a na základe toho sa určí, ktoré elementy v štandardnom DOM objekte sa majú zmeniť.

React tak redukuje túto manipuláciu na minimálny počet zmien v štandardnom DOM objekte, pretože sa prekreslujú iba tie elementy, pri ktorých je toto prekreslenie nutné. Príkladom môže byť zmena položiek v zozname dát, ktorý je zobrazený v elemente \texttt{<ul>} a jednotlivé položky v elementoch \texttt{<li>}. Pri takej zmene sa prekreslia iba tie elementy \texttt{<li>}, ktoré boli zmenené a neprekresluje sa celý zoznam.

\subsection{One-way binding}
Ďalšou dôležitou vlastnosťou v Reacte je spôsob, akým sú prepojené dáta v pamäti s elementami, ktoré ich vykreslujú. Zmena dát v pamäti je sledovaná a ihneď sa automaticky prejavuje zmenou dát v elementoch. Opačne sa však táto zmena neprejaví. Zmena v elementoch môže nastať napríklad, keď užívateľ zmení hodnotu v elemente \texttt{<input>}.

To je rozdiel napríklad oproti frameworku AngularJS, ktorý využíva \textit{two-way binding} a zmeny sa prejavujú na obidvoch stranách. V Reacte sa využíva aj pojem \textit{one-way data flow}, ktorý znamená, že dáta prúdia jedným smerom cez komponenty, z ktorých je stránka zložená. Táto architektúra tak programátorm umožňuje lepšiu kontrolu nad logikou pracujúcou s dátami.

Na zmenu dát, ktorá je vyvolaná nejakým elementom v užívateľskom rozhraní, sa využívajú natívne eventy HTML elementov (\textit{onClick}, \textit{onChange}), a tzv. event-listenery, ktoré zachytávajú vyvolanie eventov. Pri vyvolaní eventu sa zavolá priradená funkcia, v ktorej je možné zmeniť dáta aplikácie.

\subsection{State a Props}
Komponenty v Reacte majú dva základné typy dát, respektíve dva základné typy uloženia dát. Dáta môžu byť uložené bud v objekte \texttt{state} alebo v objekte \texttt{props}. \texttt{State} predstavuje stav komponenty a je možné ho v danej komponente meniť. \texttt{Props} sú všetky atribúty, ktoré do komponenty prichádzajú zvonku z miesta, v ktorom je použitá.

Hlavným rozdielom oproti objektu \texttt{state} je to, že \texttt{props} sa nemôžu meniť vo vnútri komponenty. Komponentová architektúra znamená v Reacte, že hlavná stránka sa skladá z menších komponent a tie sa môžu skladať zase z ďalších menších komponent, atď. To znamená, že komponenta, ktorá obsahuje nejaké \texttt{props}, je časťou nejakej väčšej komponenty. Práve tá môže meniť dáta, ktoré predstavujú \texttt{props} menšej komponenty a naopak priamy prístup k jej objektu \texttt{state} nemá.

\section{Redux}
Redux je framework, ktorý udržiava stav Javascriptových webových aplikácií. V ňom je možné udržiavať aplikačné dáta alebo aj stav prezentačných komponent. Tento stav je dostupný zo všetkých častí aplikácie a je tak možné zdielať dáta medzi komponentami. Výhodou je aj jednoduchá správa takýchto dát, keďže sú na jednom mieste. V reduxe sa tento stav označuje ako \textit{Store} a je to klasický Javascriptový objekt.

Na zmenu tohto stavu sa využívajú akcie a reducery. Akcie sú objekty, ktoré obsahujú typ akcie, a dáta. Dáta predstavujú nejaké nové alebo zmenené dáta v objekte \textit{Store} a typ slúži na identifikáciu akcie v reduceroch. V nich sa potom upravuje \textit{Store} na základe typu akcie a dát z nej. Reducer predstavuje nejakú časť z objektu \textit{Store} a pri vyvolaní akcie z daného reducera sa upravuje len daná časť. Akcie sa vyvolávaju pomocou reduxovej funkcie \textit{dispatch}.

Použitie týchto akcií na úpravu stavu umožňuje takto jeho jedoduchú správu a redukuje nechcené zásahy do dát. Navyše sprehľadňuje všetky úpravy napríklad pri využití nástroja na výpis do konzoly alebo zobrazenie v špecifickom okne. Takto sú pre programátora viditeľné zároveň všetky dáta v objekte \textit{Store} aj všetky zmeny dát v podobe ich akcií.

Čo sa týka úpravy danej časti objektu \textit{Store}, tá sa vždy vytvára nová, ktorá tak nahradí celú danú časť. Ak ju tvorili datové štruktúry typu objekt alebo pole, aj tie by mali byť vždy novo vytvorené a teda nie iba pôvodne upravené. Podstatou tohto spôsobu je vytvorenie nových referencií, ktoré odakzujú na objekty alebo polia, aby sa predišlo nežiadúcej zmene dát. Často je spolu s Reduxom využívaná aj knižnica Immutable.js, ktorá zabraňuje priamej zmene v datových štruktúrach využívajúcich referencie a vykonáva rôzne optimalizácie pri kopírovaní dat.

\section{Dizajn}

\section{Architektúra}
\subsection{Kontajnerové a prezentačné komponenty}
Rozdelenie komponent do kontajnerových a prezentačných je veľmi často používaný návrhový vzor pri vývoji aplikácie v Reacte. Kontajnerová komponenta by mala obsahovať všetkú aplikačnú logiku a prezentačná by mala obsahovať kód pre zobrazovanie dát, ktoré dostáva ako \texttt{props} od kontajnerovej komponenty. Taktiež napríklad funkcie pre \texttt{event-handling} by mali byť definované v kontajnerovej komponente, ďalej predané ako \texttt{props} do prezentačnej komponenty a v nej priradené k určeným elementom.

Ďalším návrhovým vzorom je tvorba prezentačných komponent bez využitia objektu \texttt{state}. Podľa toho sa rozdeľujú komponenty na \textit{statefull} a \textit{stateless} komponenty. Bez objektu \texttt{state} sa tak komponenta správa ako funkcia, ktorá sa označuje pomenovaním \textit{pure function}. Znamená to, že pre rovnaké vstupné hodnoty (v prípade komponent sú to \texttt{props}) sa vráti vždy rovnaká výstupná hodnota.

\subsection{Redux store}

\section{Implementácia}
\subsection{Konfigurácia}
\subsection{Preklad slov page}
\subsection{Praca so slovnikom page}

\chapter{Desktopový klient}

Desktopová aplikácia

\chapter{Záver}
Táto diplomová práca sa zaoberala rozšírením desktopovej aplikácie prekladového slovníku o synchronizáciu slovníkov pomocou implementovaného serveru a vytvorením webovej aplikácie slúžiacej ako frontend pre server.

Server bol implementovaný v jazyku Javascript s využitím frameworku Node.js. Slovníky sa ukladajú do súborov formátu JSON a ku každému je vytvorený príslušný súbor pre ukladanie zmien v slovníku, taktiež vo formáte JSON. 

\chapter{These are}
\section{the available}
\subsection{sectioning}
\subsubsection{commands.}
\paragraph{Paragraphs and}
\subparagraph{subparagraphs are available as well.}
Inside the text, you can also use unnumbered lists,
\begin{itemize}
  \item such as
  \item this one
  \begin{itemize}
    \item     and they can be nested as well.
    \item[>>] You can even turn the bullets into something fancier,
    \item[\S] if you so desire.
  \end{itemize}
\end{itemize}
Numbered lists are
\begin{enumerate}
  \item very
  \begin{enumerate}
    \item similar
  \end{enumerate}
\end{enumerate}
and so are description lists:
\begin{description}
  \item[Description list]
    A list of terms with a description of each term
\end{description}
The spacing of these lists is geared towards paragraphs of text.
For lists of words and phrases, the \textsf{paralist} package
offers commands
\begin{compactitem}
  \item that
  \begin{compactitem}
    \item are
    \begin{compactitem}
      \item better
      \begin{compactitem}
        \item suited
      \end{compactitem}
    \end{compactitem}
  \end{compactitem}
\end{compactitem}
\begin{compactenum}
  \item to
  \begin{compactenum}
    \item this
    \begin{compactenum}
      \item kind of
      \begin{compactenum}
        \item content.
      \end{compactenum}
    \end{compactenum}
  \end{compactenum}
\end{compactenum}
The \textsf{amsthm} package provides the commands necessary for the
typesetting of mathematical definitions, theorems, lemmas and
proofs.

%% We will define several mathematical sectioning commands.
\newtheorem{theorem}{Theorem}[section] %% The numbering of theorems
                               %% will be reset after each section.
\newtheorem{lemma}[theorem]{Lemma}         %% The numbering of lemmas
\newtheorem{corollary}[theorem]{Corollary} %% and corollaries will
                               %% share the counter with theorems.
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\begin{theorem}
  This is a theorem that offers a profound insight into the
  mathematical sectioning commands.
\end{theorem}
\begin{theorem}[Another theorem]
  This is another theorem. Unlike the first one, this theorem has
  been endowed with a name.
\end{theorem}
\begin{lemma}
  Let us suppose that $x^2+y^2=z^2$. Then
  \begin{equation}
    \biggl\langle u\biggm|\sum_{i=1}^nF(e_i,v)e_i\biggr\rangle
    =F\biggl(\sum_{i=1}^n\langle e_i|u\rangle e_i,v\biggr).
  \end{equation}
\end{lemma}
\begin{proof}
  $\nabla^2 f(x,y)=\frac{\partial^2f}{\partial x^2}+
   \frac{\partial^2f}{\partial y^2}$.
\end{proof}
\begin{corollary}
  This is a corollary.
\end{corollary}
\begin{remark}
  This is a remark.
\end{remark}

\chapter{Floats and references}
\begin{figure}
  \begin{center}
    %% PNG and JPG images can be inserted into the document as well,
    %% but their resolution needs to be adequate. The minimum is
    %% about 100 pixels per 1 centimeter or 300 pixels per 1 inch.
    %% That means that a JPG or PNG image typeset at 4 × 4 cm should
    %% be 400 × 400 px large at the bare minimum.
    %%
    %% The optimum is about 250 pixels per 1 centimeter or 600
    %% pixels per 1 inch. That means that a JPG or PNG image typeset
    %% at 4 × 4 cm should be 1000 × 1000 px large or larger.
    \includegraphics[width=4cm]{fithesis/logo/mu/fithesis-base.pdf}
  \end{center}
  \caption{The logo of the Masaryk University at 40\,mm}
  \label{fig:mulogo1}
\end{figure}

\begin{figure}
  \begin{minipage}{.66\textwidth}
    \includegraphics[width=\textwidth]{fithesis/logo/mu/fithesis-base.pdf}
  \end{minipage}
  \begin{minipage}{.33\textwidth}
    \includegraphics[width=\textwidth]{fithesis/logo/mu/fithesis-base.pdf} \\
    \includegraphics[width=\textwidth]{fithesis/logo/mu/fithesis-base.pdf}
  \end{minipage}
  \caption{The logo of the Masaryk University at $\frac23$ and
    $\frac13$ of text width}
  \label{fig:mulogo2}
\end{figure}

\begin{table}
  \begin{tabularx}{\textwidth}{lllX}
    \toprule
    Day & Min Temp & Max Temp & Summary \\
    \midrule
    Monday & $13^{\circ}\mathrm{C}$ & $21^\circ\mathrm{C}$ & A
    clear day with low wind and no adverse current advisories. \\
    Tuesday & $11^{\circ}\mathrm{C}$ & $17^\circ\mathrm{C}$ & A
    trough of low pressure will come from the northwest. \\
    Wednesday & $10^{\circ}\mathrm{C}$ &
    $21^\circ\mathrm{C}$ & Rain will spread to all parts during the
    morning. \\
    \bottomrule
  \end{tabularx}
  \caption{A weather forecast}
  \label{tab:weather}
\end{table}

The logo of the Masaryk University is shown in Figure
\ref{fig:mulogo1} and Figure \ref{fig:mulogo2} at pages
\pageref{fig:mulogo1} and \pageref{fig:mulogo2}. The weather
forecast is shown in Table \ref{tab:weather} at page
\pageref{tab:weather}. The following chapter is Chapter
\ref{chap:matheq} and starts at page \pageref{chap:matheq}.
Items \ref{item:star1}, \ref{item:star2}, and
\ref{item:star3} are starred in the following list:
\begin{compactenum}
  \item some text
  \item some other text
  \item $\star$ \label{item:star1}
  \begin{compactenum}
    \item some text
    \item $\star$ \label{item:star2}
    \item some other text
    \begin{compactenum}
      \item some text
      \item some other text
      \item yet another piece of text
      \item $\star$ \label{item:star3}
    \end{compactenum}
    \item yet another piece of text
  \end{compactenum}
  \item yet another piece of text
\end{compactenum}
If your reference points to a place that has not yet been typeset,
the \verb"\ref" command will expand to \textbf{??} during the first
run of
\texttt{pdflatex \jobname.tex}
and a second run is going to be needed for the references to
resolve. With online services -- such as Overleaf -- this is
performed automatically.

\chapter{Mathematical equations}
\label{chap:matheq}
\TeX{} comes pre-packed with the ability to typeset inline
equations, such as $\mathrm{e}^{ix}=\cos x+i\sin x$, and display
equations, such as \[
  \mathbf{A}^{-1} = \begin{bmatrix}
  a & b \\ c & d \\
  \end{bmatrix}^{-1} =
  \frac{1}{\det(\mathbf{A})} \begin{bmatrix}
  \,\,\,d & \!\!-b \\ -c & \,a \\
  \end{bmatrix} =
  \frac{1}{ad - bc} \begin{bmatrix}
  \,\,\,d & \!\!-b \\ -c & \,a \\
  \end{bmatrix}.
\] \LaTeX{} defines the automatically numbered \texttt{equation}
environment:
\begin{equation}
  \gamma Px = PAx = PAP^{-1}Px.
\end{equation}
The package \textsf{amsmath} provides several additional
environments that can be used to typeset complex equations:
\begin{enumerate}
  \item An equation can be spread over multiple lines using the
    \texttt{multline} environment:
    \begin{multline}
      a + b + c + d + e + f + b + c + d + e + f + b + c + d + e +
f \\
      + f + g + h + i + j + k + l + m + n + o + p + q
    \end{multline}

  \item Several aligned equations can be typeset using the
    \texttt{align} environment:
    \begin{align}
              a + b &= c + d     \\
                  u &= v + w + x \\[1ex]
      i + j + k + l &= m
    \end{align}

  \item The \texttt{alignat} environment is similar to
    \texttt{align}, but it doesn't insert horizontal spaces between
    the individual columns:
    \begin{alignat}{2}
      a + b + c &+ d       &   &= 0 \\
              e &+ f + g   &   &= 5
    \end{alignat}

  \item Much like chapter, sections, tables, figures, or list
    items, equations -- such as \eqref{eq:first} and
    \eqref{eq:mine} -- can also be labeled and referenced:
    \begin{alignat}{4}
      b_{11}x_1 &+ b_{12}x_2  &  &+ b_{13}x_3  &  &             &
        &= y_1,                   \label{eq:first} \\
      b_{21}x_1 &+ b_{22}x_2  &  &             &  &+ b_{24}x_4  &
        &= y_2. \tag{My equation} \label{eq:mine}
    \end{alignat}

  \item The \texttt{gather} environment makes it possible to
    typeset several equations without any alignment:
    \begin{gather}
      \psi = \psi\psi, \\
      \eta = \eta\eta\eta\eta\eta\eta, \\
      \theta = \theta.
    \end{gather}

  \item Several cases can be typeset using the \texttt{cases}
    environment:
    \begin{equation}
      |y| = \begin{cases}
        \phantom-y & \text{if }z\geq0, \\
                -y & \text{otherwise}.
      \end{cases}
    \end{equation}
\end{enumerate}
For the complete list of environments and commands, consult the
\textsf{amsmath} package manual\footnote{
  See \url{http://mirrors.ctan.org/macros/latex/required/amslatex/math/amsldoc.pdf}.
  The \texttt{\textbackslash url} command is provided by the
  package \textsf{url}.
}.

\chapter{\textnormal{We \textsf{have} \texttt{several} \textsc{fonts}
  \textit{at} \textbf{disposal}}}
The serified roman font is used for the main body of the text.
\textit{Italics are typically used to denote emphasis or
quotations.} \texttt{The teletype font is typically used for source
code listings.} The \textbf{bold}, \textsc{small-caps} and
\textsf{sans-serif} variants of the base roman font can be used to
denote specific types of information.

\tiny We \scriptsize can \footnotesize also \small change \normalsize
the \large font \Large size, \LARGE although \huge it \Huge
is \huge usually \LARGE not \Large necessary.\normalsize

A wide variety of mathematical fonts is also available, such as: \[
  \mathrm{ABC}, \mathcal{ABC}, \mathbf{ABC}, \mathsf{ABC},
  \mathit{ABC}, \mathtt{ABC}
\] By loading the \textsf{amsfonts} packages, several additional
fonts will become available: \[
  \mathfrak{ABC}, \mathbb{ABC}
\] Many other mathematical fonts are available\footnote{
  See \url{http://tex.stackexchange.com/a/58124/70941}.
}.

\chapter{Using lightweight markup}
\shorthandoff{-}
\begin{markdown*}{%
  hybrid,
  definitionLists,
  footnotes,
  hashEnumerators}

If you decide that \LaTeX{} is too wordy for some parts of your
document, there are [packages](https://www.ctan.org/pkg/markdown
"Markdown") that allow you to use more lightweight markup next
to it.

 ![logo](fithesis/logo/mu/fithesis-base.pdf "The logo of the
  Masaryk University")

This is a bullet list. Unlike numbered lists, bulleted lists
contain an **unordered** set of bullet points. When a bullet point
contains multiple paragraphs, the list is typeset as follows:

  * The first item of a bullet list

    that spans several paragraphs,
  * the second item of a bullet list,
  * the third item of a bullet list.

When none of the bullet points contains multiple paragraphs, the
list has a more compact form:

  * The first item of a bullet list,
  * the second item of a bullet list,
  * the third item of a bullet list.

Unlike a bulleted list, a numbered list implies chronology or
ordering of the bullet points. When a bullet point
contains multiple paragraphs, the list is typeset as follows:

  1. The first item of an ordered list

     that spans several paragraphs,
  2. the second item of an ordered list,
  3. the third item of an ordered list.
  #. If you are feeling lazy,
  #. you can use hash enumerators as well.

When none of the bullet points contains multiple paragraphs, the
list has a more compact form:

  6. The first item of an ordered list,
  7. the second item of an ordered list,
  8. the third item of an ordered list.

Definition lists are used to provide definitions of terms. When
a definition contains multiple paragraphs, the list is typeset
as follows:

Term 1

:   Definition 1

*Term 2*

:   Definition 2

        Some code, part of Definition 2

    Third paragraph of Definition 2.

When none of the bullet points contains multiple paragraphs, the
list has a more compact form:

Term 1
:   Definition 1
*Term 2*
:   Definition 2

Block quotations are used to include an excerpt from an external
document in way that visually clearly separates the excerpt from
the rest of the work:

> This is the first level of quoting.
>
> > This is nested blockquote.
>
> Back to the first level.

Footnotes are used to include additional information to the
document that are not necessary for the understanding of the main
text. Here is a footnote reference[^1] and another[^longnote].

[^1]: Here is the footnote.

[^longnote]: Here's one with multiple blocks.

    Subsequent paragraphs are indented to show that they
belong to the previous footnote.

        Some code

    The whole paragraph can be indented, or just the first
    line.  In this way, multi-paragraph footnotes work like
    multi-paragraph list items.
\end{markdown*}
\shorthandon{-}

\chapter{Inserting the bibliography}
After linking a bibliography data\-base files to the document using
the \verb"\"\texttt{thesissetup\{bib\discretionary{=}{=}{=}%
\{\textit{file1},\textit{file2},\,\ldots\,\}\}} command, you can
start citing the entries. This is just dummy text
\parencite{borgman03} lightly sprinkled with citations
\parencite[p.~123]{greenberg98}. Several sources can be cited at
once: \cite{borgman03,greenberg98,thanh01}.
\citetitle{greenberg98} was written by \citeauthor{greenberg98} in
\citeyear{greenberg98}. We can also produce \textcite{greenberg98}%
\ or %% Let us define a compound command:
\def\citeauthoryear#1{(\textcite{#1},~\citeyear{#1})}%
\citeauthoryear{greenberg98}%
. The full bibliographic citation is:
\emph{\fullcite{greenberg98}}. We can easily insert a bibliographic
citation into the footnote\footfullcite{greenberg98}.

The \verb"\nocite" command will not generate any
output\nocite{muni}, but it will insert its arguments into
the bibliography. The \verb"\nocite{*}" command will insert all the
records in the bibliography database file into the bibliography.
Try uncommenting the command
%% \nocite{*}
and watch the bibliography section come apart at the seams.

When typesetting the document for the first time, citing a
\texttt{work} will expand to [\textbf{work}] and the
\verb"\printbibliography" command will produce no output. It is now
necessary to generate the bibliography by running \texttt{biber
\jobname.bcf} from the command line and then by typesetting the
document again twice. During the first run, the bibliography
section and the citations will be typeset, and in the second run,
the bibliography section will appear in the table of contents.

The \texttt{biber} command needs to be executed from within the
directory, where the \LaTeX\ source file is located. In Windows,
the command line can be opened in a directory by holding down the
\textsf{Shift} key and by clicking the right mouse button while
hovering the cursor over a directory.  Select the \textsf{Open
Command Window Here} option in the context menu that opens shortly
afterwards.

With online services -- such as Overleaf -- or when using an
automatic tool -- such as \LaTeX MK -- all commands are executed
automatically. When you omit the \verb"\printbibliography" command,
its location will be decided by the template.

  \printbibliography[heading=bibintoc] %% Print the bibliography.

\chapter{Inserting the index}
After using the \verb"\makeindex" macro and loading the
\texttt{makeidx} package that provides additional indexing
commands, index entries can be created by issuing the \verb"\index"
command. \index{dummy text|(}It is possible to create ranged index
entries, which will encompass a span of text.\index{dummy text|)}
To insert complex typographic material -- such as $\alpha$
\index{alpha@$\alpha$} or \TeX{} \index{TeX@\TeX} --
into the index, you need to specify a text string, which will
determine how the entry will be sorted. It is also possible to
create hierarchal entries. \index{vehicles!trucks}
\index{vehicles!speed cars}

After typesetting the document, it is necessary to generate the
index by running
\begin{center}%
  \texttt{texindy -I latex -C utf8 -L }$\langle$\textit{locale}%
  $\rangle$\texttt{ \jobname.idx}
\end{center}
from the command line, where $\langle$\textit{locale}$\rangle$
corresponds to the main locale of your thesis -- such as
\texttt{slovak}, and then typesetting the document again.

The \texttt{texindy} command needs to be executed from within the
directory, where the \LaTeX\ source file is located. In Windows,
the command line can be opened in a directory by holding down the
\textsf{Shift} key and by clicking the right mouse button while
hovering the cursor over a directory. Select the \textsf{Open Command
Window Here} option in the context menu that opens shortly
afterwards.

With online services -- such as Overleaf -- the commands are
executed automatically, although the locale may be erroneously
detected, or the \texttt{makeindex} tool (which is only able to
sort entries that contain digits and letters of the English
alphabet) may be used instead of \texttt{texindy}. In either case,
the index will be ill-sorted.

  \makeatletter\thesis@blocks@clear\makeatother
  \phantomsection %% Print the index and insert it into the
  \addcontentsline{toc}{chapter}{\indexname} %% table of contents.
  \printindex

\appendix %% Start the appendices.
\chapter{An appendix}
Here you can insert the appendices of your thesis.

\end{document}
